<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Doodle World</title>
    <meta name="description" content="">
    <meta name="author" content="qingyuanxingsi">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
    <script src="./theme/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.1.1/css/bootstrap.no-icons.min.css" rel="stylesheet">
    <link href="./theme/local.css" rel="stylesheet">
    <link href="./theme/pygments.css" rel="stylesheet">
    <link href="./theme/font-awesome.css" rel="stylesheet">
    <link href='http://fonts.googleapis.com/css?family=Gudea:400,400italic|Alegreya+SC' rel='stylesheet' type='text/css'>
</head>

<body>
<header class="blog-header">
  <div class="container">
    <div class="row-fluid">
      <div class="span9">
	<a href="." class="brand">Doodle World</a>
      </div>

      <div class="span3" id="blog-nav">
	<ul class="nav nav-pills pull-right">
            <li><a href="./pages/about.html">About</a></li>
	    <li >
	      <a href="./category/distributed-system.html ">Distributed System</a>
	    <li >
	      <a href="./category/life.html ">Life</a>
	    <li >
	      <a href="./category/machine-learning.html ">Machine Learning</a>
	    <li >
	      <a href="./category/viewpoint.html ">Viewpoint</a>
	</ul>
      </div>
    </div> <!-- End of fluid row-->
  </div>   <!-- End of Container-->
</header>
    
<div class="container">
    <div class="content">
    <div class="row-fluid">

        <div class="span10">
        

        

    <div class='row-fluid''>
        <div class="article-title span9">
            <a href="./fen-bu-shi-ji-suan-xi-lie-iyarnji-chu-ku-chu-tan.html"><h1>分布式计算系列(I):Yarn基础库初探</h1></a>
        </div>
    </div>
    <div class="row-fluid">
      <div class="span2">
<p>六 22 三月 2014 </p>

<p style="text-align: left;">
Filed under <a href="./category/distributed-system.html">Distributed System</a>
</p>
<p style="text-align: left;">
 
    Tags <a href="./tag/rpc.html">RPC</a> <a href="./tag/yarn.html">YARN</a> <a href="./tag/hadoop.html">Hadoop</a> <a href="./tag/state-machine.html">State Machine</a> <a href="./tag/designing-patterns.html">Designing Patterns</a> <a href="./tag/reactor-pattern.html">Reactor Pattern</a> <a href="./tag/proxy-pattern.html">Proxy Pattern</a> </p>
<p>
</p>
      </div>
      <div class="article-content span8">
	<h1>PREFACE</h1>
<hr>
<p>在上一篇<a href="http://www.qingyuanxingsi.com/fen-bu-shi-ji-suan-yu-cun-chu-xi-lie-xu-zhang-chu-ru-men-jing.html">分布式计算与存储系列(序章):初入门径</a>中,我们主要介绍了分布式存储的一些基础知识,在本系列中,我们会结合论文以及源码对分布式计算的基本理论以及一些应用系统进行研究，以期对分布式系统有一个更为深入的了解。本系列的前若干篇均以研究Yarn为主,主要参考<a href="http://book.douban.com/subject/25774649/">Hadoop技术内幕:深入解析YARN架构设计与实现原理</a>一书的整体架构,但是个人对这本书不是特别满意，讲述的还是有点浅,很多问题只是浅尝则止而已。(真正想<code>深入</code>了解YARN的不建议购买本书，如若只是想粗略的了解一下YARN的工作流程的童鞋倒是可以入手一本滴。)因此，本系列仅会采用其大体框架，在其大体框架下，对YARN设计的其他知识和设计模式等也会有进一步更为深入的介绍。好吧，闲话就不多说了,我们开始正式讨论。</p>
<p>本文的主要目的是介绍一下YARN中用到的基础库,它们是YARN其他模块得以建立的基石,其重要性自然不言而喻。我们先从其RPC库说起。</p>
<h1>The Secret of RPC</h1>
<hr>
<p>当前存在非常多的开源 RPC 框架,比较有名的有 Thrift、Protocol Buffers 和 Avro。同Hadoop RPC一样,它们均由两部分组成:对象序列化和远程过程调用(Protocol Buflers官方仅提供了序列化实现,未提供远程调用相关实现,但三方 RPC 库非常多 )。相比于Hadoop RPC,它们有以下几个特点:</p>
<ul>
<li><strong>跨语言特性</strong>。对于 Hadoop RPC而言,由于Hadoop采用 Java 语言编写,因而其RPC客户端和服务器端仅支持Java语言;但对于更通用的 RPC框架,如Thrift或者Protocol Buffers等,其客户端和服务器端可采用任何语言编写,如Java、C++、Python等,这给用户编程带来极大方便。</li>
<li><strong>引入IDL</strong>。开源RPC框架均提供了一套接口描述语言(Interface Description Language,IDL),它提供一套通用的数据类型,并以这些数据类型来定义更为复杂的数据类型和对外服务接口。一旦用户按照IDL定义的语法编写完接口文件后,可根据实际应用需要生成特定编程语言(如 Java、C++、Python 等)的客户端和服务器端代码。</li>
<li><strong>协议兼容性</strong>。开源RPC框架在设计上均考虑到了协议兼容性问题,即当协议格式发生改变时,比如某个类需要添加或者删除一个成员变量(字段)后,旧版本代码仍然能识别新格式的数据,也就是说,具有向后兼容性。</li>
</ul>
<p>随着Hadoop版本的不断演化,研发人员发现Hadoop RPC在跨语言支持和协议兼容性两个方面存在不足,具体表现为:</p>
<ul>
<li>从长远发展看,Hadoop RPC应允许某些协议的客户端或者服务器端采用其他语言实现,比如用户希望直接使用C/C++语言读写HDFS中的文件,这就需要有C/C++语言的HDFS客户端。</li>
<li>当前 Hadoop 版本较多,而不同版本之间不能通信,比如0.20.2版本的JobTracker不能与0.21.0版本中的TaskTracker通信,如果用户企图这样做,会抛出<em>VersionMismatch</em>异常。</li>
</ul>
<p>为了解决以上几个问题,Hadoop YARN将RPC中的序列化部分剥离开,以便将现有的开源RPC框架集成进来。Hadoop目前集成了Protocol Buffer以及Apache Avro的序列化部分,而函数调用调用机制仍采用Hadoop自带的,其中RPC采用Protocol Buffer,而Apache Avro则用于日志系统。以下对这两种序列化机制进行一个简要的介绍:</p>
<h2>持久化框架</h2>
<h3>Protocol Buffer<sup id="sf-fen-bu-shi-ji-suan-xi-lie-iyarnji-chu-ku-chu-tan-1-back"><a href="#sf-fen-bu-shi-ji-suan-xi-lie-iyarnji-chu-ku-chu-tan-1" class="simple-footnote" title="https://developers.google.com/protocol-buffers/docs/javatutorial">1</a></sup></h3>
<p>Protocol Buffers 是一种轻便高效的结构化数据存储格式,可以用于结构化数据序列化/反序列化。它很适合做数据存储或RPC的数据交换格式,常用作通信协议、数据存储等领域的与语言无关、平台无关、可扩展的序列化结构数据格式。目前支持C++、Java、Python三种语言。在
Google 内部,几乎所有的RPC协议和文件格式都是采用Protocol Buffers。</p>
<p>相比于常见的XML格式,Protocol Buffers官方网站这样描述它的优点:</p>
<ul>
<li>平台无关、语言无关;</li>
<li>高性能,解析速度是 XML 的 20 ~ 100 倍;</li>
<li>体积小,文件大小仅是 XML 的 1/10 ~ 1/3;</li>
<li>使用简单;</li>
<li>兼容性好。</li>
</ul>
<p>通常编写一个 Protocol Buffers 应用需要以下三步:</p>
<ul>
<li>定义报文格式(.proto文件)</li>
<li>使用Protocol Buffer Compiler编译生成JAVA类</li>
<li>使用Protocol Buffer API读写报文</li>
</ul>
<h4>定义报文格式</h4>
<p>我们首先定义消息格式文件addressbook.proto,以下定义了一个人的通讯录的基本信息:</p>
<div class="highlight"><pre><span class="n">package</span> <span class="n">tutorial</span><span class="p">;</span>

<span class="n">option</span> <span class="n">java_package</span> <span class="o">=</span> <span class="s">"com.qingyuanxingsi.tutorial"</span><span class="p">;</span>
<span class="n">option</span> <span class="n">java_outer_classname</span> <span class="o">=</span> <span class="s">"AddressBookProtos"</span><span class="p">;</span>

<span class="n">message</span> <span class="n">Person</span> <span class="p">{</span>
    <span class="n">required</span> <span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">required</span> <span class="n">int32</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">optional</span> <span class="n">string</span> <span class="n">email</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

    <span class="k">enum</span> <span class="n">PhoneType</span> <span class="p">{</span>
        <span class="n">MOBILE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">HOME</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">WORK</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">message</span> <span class="n">PhoneNumber</span> <span class="p">{</span>
        <span class="n">required</span> <span class="n">string</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">optional</span> <span class="n">PhoneType</span> <span class="n">type</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">[</span><span class="k">default</span> <span class="o">=</span> <span class="n">HOME</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">repeated</span> <span class="n">PhoneNumber</span> <span class="n">phone</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">message</span> <span class="n">AddressBook</span> <span class="p">{</span>
    <span class="n">repeated</span> <span class="n">Person</span> <span class="n">person</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>.proto文件开头包含一个包声明,以避免不同Project之间的命名冲突。Java中，package名即被用作Java包名,除非通过<code>java_package</code>另外显式指定表明。以上我们制定生成的包名为<code>com.qingyuanxingsi.tutorial</code>.<code>java_outer_classname</code>则指定了类名，我们生成的所有类均会被放在这个文件中。如果未显式制定，则会将文件名自动转化成Camel形式的类名。如,<code>my_proto.proto</code>默认情况下会生成<code>MyProto</code>作为其类名。</p>
<p>接下来则是报文定义。一个报文即是一系列带有类型信息的Field的集合。很多简单数据类型可被用作Field Type,包括bool, int32, float, double, and string. 当然，你也可以自定义类型作为Field Type.在上述例子中,Person报文就包含PhoneNumber报文,AddressBook报文则包括Person报文。另外,报文可被嵌套定义,如PhoneNumber就定义在Person报文中。如果你想让你的某个Field具有一个或多个预定义的值,你可以使用枚举类型，如上述，我们想让电话号码类型取MOBILE, HOME, or WORK中的值。每个字段后的<code>=？</code>标记为每个Field分配了唯一的TAG,以用于二进制编码。</p>
<p><code>required</code>关键字指定该Field必须被赋值，否则报文将会被视为<code>uninitialized</code>.编译此类报文则会抛出<em>RuntimeException</em>异常,除此之外,它与optional field基本相同。<code>optional</code>关键字则表明该Field可被设置，也可不设置。如果未设置,则会使用默认值。对于简单数据类型，我们可以定义我们自己的默认值,否则则会使用系统默认值。对于嵌套报文,默认值则通常会是报文的默认实例或者原型,其中每一个Field均未被设置。repeated则表明该字段可以重复任何多次。</p>
<h4>编译生成JAVA类</h4>
<p>使用以下命令即可生成相应的JAVA类:</p>
<div class="highlight"><pre><span class="n">protoc</span> <span class="o">-</span><span class="n">I</span><span class="o">=</span><span class="err">$</span><span class="n">SRC_DIR</span> <span class="o">--</span><span class="n">java_out</span><span class="o">=</span><span class="err">$</span><span class="n">DST_DIR</span> <span class="err">$</span><span class="n">SRC_DIR</span><span class="o">/</span><span class="n">addressbook</span><span class="p">.</span><span class="n">proto</span>
</pre></div>


<p>生成的类的结构如下图所示(此处不再给出源码):</p>
<p><img alt="AddressBook Struture" src="http://i1302.photobucket.com/albums/ag136/qingyuanxingsi/blog/addressBook_zps34178bad.png"></p>
<h4>使用Protocol Buffer API读写报文</h4>
<p>如上图所示,我们可以看到一个<code>AddressBookProtos.java</code>类,其中则嵌套了多个类,每个类均有.proto中定义的message生成。每个类都有对应的一个<code>Builder</code>类,可以用于构造类实例。</p>
<p>报文类以及Builder类对于报文的每个Field均提供了访问器。值得注意的是,报文类仅提供了getters,而Builder类既有getters,又有setters.以下给出Person类的一个实例:</p>
<div class="highlight"><pre><span class="c1">// required string name = 1;</span>
<span class="n">public</span> <span class="n">boolean</span> <span class="n">hasName</span><span class="p">();</span>
<span class="n">public</span> <span class="n">String</span> <span class="n">getName</span><span class="p">();</span>

<span class="c1">// required int32 id = 2;</span>
<span class="n">public</span> <span class="n">boolean</span> <span class="n">hasId</span><span class="p">();</span>
<span class="n">public</span> <span class="k">int</span> <span class="n">getId</span><span class="p">();</span>

<span class="c1">// optional string email = 3;</span>
<span class="n">public</span> <span class="n">boolean</span> <span class="n">hasEmail</span><span class="p">();</span>
<span class="n">public</span> <span class="n">String</span> <span class="n">getEmail</span><span class="p">();</span>

<span class="c1">// repeated .tutorial.Person.PhoneNumber phone = 4;</span>
<span class="n">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">PhoneNumber</span><span class="o">&gt;</span> <span class="n">getPhoneList</span><span class="p">();</span>
<span class="n">public</span> <span class="k">int</span> <span class="n">getPhoneCount</span><span class="p">();</span>
<span class="n">public</span> <span class="n">PhoneNumber</span> <span class="n">getPhone</span><span class="p">(</span><span class="k">int</span> <span class="n">index</span><span class="p">);</span>
</pre></div>


<p>而与其对应的Builder类则getters和setters都有:</p>
<div class="highlight"><pre><span class="c1">// required string name = 1;</span>
<span class="n">public</span> <span class="n">boolean</span> <span class="n">hasName</span><span class="p">();</span>
<span class="n">public</span> <span class="n">java</span><span class="p">.</span><span class="n">lang</span><span class="p">.</span><span class="n">String</span> <span class="n">getName</span><span class="p">();</span>
<span class="n">public</span> <span class="n">Builder</span> <span class="n">setName</span><span class="p">(</span><span class="n">String</span> <span class="n">value</span><span class="p">);</span>
<span class="n">public</span> <span class="n">Builder</span> <span class="n">clearName</span><span class="p">();</span>

<span class="c1">// required int32 id = 2;</span>
<span class="n">public</span> <span class="n">boolean</span> <span class="n">hasId</span><span class="p">();</span>
<span class="n">public</span> <span class="k">int</span> <span class="n">getId</span><span class="p">();</span>
<span class="n">public</span> <span class="n">Builder</span> <span class="n">setId</span><span class="p">(</span><span class="k">int</span> <span class="n">value</span><span class="p">);</span>
<span class="n">public</span> <span class="n">Builder</span> <span class="n">clearId</span><span class="p">();</span>

<span class="c1">// optional string email = 3;</span>
<span class="n">public</span> <span class="n">boolean</span> <span class="n">hasEmail</span><span class="p">();</span>
<span class="n">public</span> <span class="n">String</span> <span class="n">getEmail</span><span class="p">();</span>
<span class="n">public</span> <span class="n">Builder</span> <span class="n">setEmail</span><span class="p">(</span><span class="n">String</span> <span class="n">value</span><span class="p">);</span>
<span class="n">public</span> <span class="n">Builder</span> <span class="n">clearEmail</span><span class="p">();</span>

<span class="c1">// repeated .tutorial.Person.PhoneNumber phone = 4;</span>
<span class="n">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">PhoneNumber</span><span class="o">&gt;</span> <span class="n">getPhoneList</span><span class="p">();</span>
<span class="n">public</span> <span class="k">int</span> <span class="n">getPhoneCount</span><span class="p">();</span>
<span class="n">public</span> <span class="n">PhoneNumber</span> <span class="n">getPhone</span><span class="p">(</span><span class="k">int</span> <span class="n">index</span><span class="p">);</span>
<span class="n">public</span> <span class="n">Builder</span> <span class="n">setPhone</span><span class="p">(</span><span class="k">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">PhoneNumber</span> <span class="n">value</span><span class="p">);</span>
<span class="n">public</span> <span class="n">Builder</span> <span class="n">addPhone</span><span class="p">(</span><span class="n">PhoneNumber</span> <span class="n">value</span><span class="p">);</span>
<span class="n">public</span> <span class="n">Builder</span> <span class="n">addAllPhone</span><span class="p">(</span><span class="n">Iterable</span><span class="o">&lt;</span><span class="n">PhoneNumber</span><span class="o">&gt;</span> <span class="n">value</span><span class="p">);</span>
<span class="n">public</span> <span class="n">Builder</span> <span class="n">clearPhone</span><span class="p">();</span>
</pre></div>


<p>由Protocol Buffer Compiler编译生成的message类均是不可变的。Message实例一旦生成，就不能更改。为了构造一个message，我们首先构造一个builder,将Field设置成你想要的值,然后调用builder的build()方法。以下代码用于构造一个Person实例:</p>
<div class="highlight"><pre><span class="n">Person</span> <span class="n">john</span> <span class="o">=</span>
    <span class="n">Person</span><span class="p">.</span><span class="n">newBuilder</span><span class="p">()</span>
    <span class="p">.</span><span class="n">setId</span><span class="p">(</span><span class="mi">1234</span><span class="p">)</span>
    <span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="s">"John Doe"</span><span class="p">)</span>
    <span class="p">.</span><span class="n">setEmail</span><span class="p">(</span><span class="s">"jdoe@example.com"</span><span class="p">)</span>
    <span class="p">.</span><span class="n">addPhone</span><span class="p">(</span>
    <span class="n">Person</span><span class="p">.</span><span class="n">PhoneNumber</span><span class="p">.</span><span class="n">newBuilder</span><span class="p">()</span>
    <span class="p">.</span><span class="n">setNumber</span><span class="p">(</span><span class="s">"555-4321"</span><span class="p">)</span>
    <span class="p">.</span><span class="n">setType</span><span class="p">(</span><span class="n">Person</span><span class="p">.</span><span class="n">PhoneType</span><span class="p">.</span><span class="n">HOME</span><span class="p">))</span>
<span class="p">.</span><span class="n">build</span><span class="p">();</span>
</pre></div>


<p>最后,每个Protocol Buffer类军定义了读写报文的方法,如下所示:</p>
<ul>
<li>byte[] toByteArray();持久化message对象并返回包含一字节数组。</li>
<li>static Person parseFrom(byte[] data);通过给定字节数组解析构造报文实例。</li>
<li>void writeTo(OutputStream output);将报文持久化到OutputStream中.</li>
<li>static Person parseFrom(InputStream input);解析InputStream并构造报文实例.</li>
</ul>
<p>至此,我们给出一个报文读写实例,它用于将报文持久化到文件中然后从文件中解析构造得到原始报文:</p>
<div class="highlight"><pre><span class="n">package</span> <span class="n">org</span><span class="p">.</span><span class="n">qingyuanxingsi</span><span class="p">.</span><span class="n">protoc</span><span class="p">;</span>

<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">File</span><span class="p">;</span>
<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">FileInputStream</span><span class="p">;</span>
<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">FileNotFoundException</span><span class="p">;</span>
<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">FileOutputStream</span><span class="p">;</span>
<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">IOException</span><span class="p">;</span>

<span class="n">import</span> <span class="n">com</span><span class="p">.</span><span class="n">qingyuanxingsi</span><span class="p">.</span><span class="n">tutorial</span><span class="p">.</span><span class="n">AddressBookProtos</span><span class="p">.</span><span class="n">AddressBook</span><span class="p">;</span>
<span class="n">import</span> <span class="n">com</span><span class="p">.</span><span class="n">qingyuanxingsi</span><span class="p">.</span><span class="n">tutorial</span><span class="p">.</span><span class="n">AddressBookProtos</span><span class="p">.</span><span class="n">Person</span><span class="p">;</span>
<span class="n">import</span> <span class="n">com</span><span class="p">.</span><span class="n">qingyuanxingsi</span><span class="p">.</span><span class="n">tutorial</span><span class="p">.</span><span class="n">AddressBookProtos</span><span class="p">.</span><span class="n">Person</span><span class="p">.</span><span class="n">PhoneNumber</span><span class="p">;</span>
<span class="n">import</span> <span class="n">com</span><span class="p">.</span><span class="n">qingyuanxingsi</span><span class="p">.</span><span class="n">tutorial</span><span class="p">.</span><span class="n">AddressBookProtos</span><span class="p">.</span><span class="n">Person</span><span class="p">.</span><span class="n">PhoneType</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * A toy example demonstrates the writing and reading process to an address book</span>
<span class="cm"> * proto.</span>
<span class="cm"> * </span>
<span class="cm"> * @author qingyuanxingsi</span>
<span class="cm"> * </span>
<span class="cm"> */</span>
<span class="n">public</span> <span class="n">class</span> <span class="n">AddressBookDemo</span> <span class="p">{</span>
    <span class="n">private</span> <span class="k">static</span> <span class="n">final</span> <span class="n">String</span> <span class="n">FILE_PATH</span> <span class="o">=</span> <span class="s">"addressbook.dat"</span><span class="p">;</span>

    <span class="n">public</span> <span class="k">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// TODO Auto-generated method stub</span>
        <span class="n">addPerson</span><span class="p">();</span>
        <span class="n">printData</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="cm">/**</span>
<span class="cm">     * Print the data out</span>
<span class="cm">     */</span>
    <span class="n">public</span> <span class="k">static</span> <span class="kt">void</span> <span class="nf">printData</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// TODO Auto-generated method stub</span>
        <span class="n">try</span> <span class="p">{</span>
            <span class="n">AddressBook</span> <span class="n">addressBook</span> <span class="o">=</span> <span class="n">AddressBook</span>
                    <span class="p">.</span><span class="n">parseFrom</span><span class="p">(</span><span class="n">new</span> <span class="n">FileInputStream</span><span class="p">(</span><span class="n">new</span> <span class="n">File</span><span class="p">(</span><span class="n">FILE_PATH</span><span class="p">)));</span>
            <span class="n">print</span><span class="p">(</span><span class="n">addressBook</span><span class="p">);</span>
        <span class="p">}</span> <span class="n">catch</span> <span class="p">(</span><span class="n">FileNotFoundException</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// TODO Auto-generated catch block</span>
            <span class="n">e</span><span class="p">.</span><span class="n">printStackTrace</span><span class="p">();</span>
        <span class="p">}</span> <span class="n">catch</span> <span class="p">(</span><span class="n">IOException</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// TODO Auto-generated catch block</span>
            <span class="n">e</span><span class="p">.</span><span class="n">printStackTrace</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/**</span>
<span class="cm">     * Print the whole all data</span>
<span class="cm">     * </span>
<span class="cm">     * @param addressBook</span>
<span class="cm">     */</span>
    <span class="n">public</span> <span class="k">static</span> <span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="n">AddressBook</span> <span class="n">addressBook</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// TODO Auto-generated method stub</span>
        <span class="c1">//Iterate over the address book</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">Person</span> <span class="n">person</span> <span class="o">:</span> <span class="n">addressBook</span><span class="p">.</span><span class="n">getPersonList</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"Person ID: "</span> <span class="o">+</span> <span class="n">person</span><span class="p">.</span><span class="n">getId</span><span class="p">());</span>
            <span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"Person Name: "</span> <span class="o">+</span> <span class="n">person</span><span class="p">.</span><span class="n">getName</span><span class="p">());</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">person</span><span class="p">.</span><span class="n">hasEmail</span><span class="p">())</span> <span class="p">{</span>
                <span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"E-mail address: "</span> <span class="o">+</span> <span class="n">person</span><span class="p">.</span><span class="n">getEmail</span><span class="p">());</span>
            <span class="p">}</span>

            <span class="c1">//Get phone numbers</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">Person</span><span class="p">.</span><span class="n">PhoneNumber</span> <span class="n">phoneNumber</span> <span class="o">:</span> <span class="n">person</span><span class="p">.</span><span class="n">getPhoneList</span><span class="p">())</span> <span class="p">{</span>
                <span class="k">switch</span> <span class="p">(</span><span class="n">phoneNumber</span><span class="p">.</span><span class="n">getType</span><span class="p">())</span> <span class="p">{</span>
                <span class="k">case</span> <span class="n">MOBILE</span>:
                    <span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"Mobile phone #: "</span><span class="p">);</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="n">HOME</span>:
                    <span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"Home phone #: "</span><span class="p">);</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="n">WORK</span>:
                    <span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">"Work phone #: "</span><span class="p">);</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">phoneNumber</span><span class="p">.</span><span class="n">getNumber</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/**</span>
<span class="cm">     * Add a person to the address book file</span>
<span class="cm">     */</span>
    <span class="n">public</span> <span class="k">static</span> <span class="kt">void</span> <span class="nf">addPerson</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// TODO Auto-generated method stub</span>
        <span class="n">Person</span> <span class="n">person</span> <span class="o">=</span> <span class="n">Person</span>
                <span class="p">.</span><span class="n">newBuilder</span><span class="p">()</span>
                <span class="p">.</span><span class="n">setId</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="s">"qingyuanxingsi"</span><span class="p">)</span>
                <span class="p">.</span><span class="n">setEmail</span><span class="p">(</span><span class="s">"demo@server.com"</span><span class="p">)</span>
                <span class="p">.</span><span class="n">addPhone</span><span class="p">(</span>
                        <span class="n">PhoneNumber</span><span class="p">.</span><span class="n">newBuilder</span><span class="p">().</span><span class="n">setNumber</span><span class="p">(</span><span class="s">"13456723421"</span><span class="p">)</span>
                                <span class="p">.</span><span class="n">setType</span><span class="p">(</span><span class="n">PhoneType</span><span class="p">.</span><span class="n">MOBILE</span><span class="p">).</span><span class="n">build</span><span class="p">()).</span><span class="n">build</span><span class="p">();</span>
        <span class="n">AddressBook</span> <span class="n">addressBook</span> <span class="o">=</span> <span class="n">AddressBook</span><span class="p">.</span><span class="n">newBuilder</span><span class="p">().</span><span class="n">addPerson</span><span class="p">(</span><span class="n">person</span><span class="p">)</span>
                <span class="p">.</span><span class="n">build</span><span class="p">();</span>
        <span class="c1">// System.out.println(person);</span>
        <span class="n">FileOutputStream</span> <span class="n">outputStream</span><span class="p">;</span>
        <span class="n">try</span> <span class="p">{</span>
            <span class="n">outputStream</span> <span class="o">=</span> <span class="n">new</span> <span class="n">FileOutputStream</span><span class="p">(</span><span class="n">new</span> <span class="n">File</span><span class="p">(</span><span class="n">FILE_PATH</span><span class="p">));</span>
            <span class="n">addressBook</span><span class="p">.</span><span class="n">writeTo</span><span class="p">(</span><span class="n">outputStream</span><span class="p">);</span>
            <span class="n">outputStream</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
        <span class="p">}</span> <span class="n">catch</span> <span class="p">(</span><span class="n">FileNotFoundException</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// TODO Auto-generated catch block</span>
            <span class="n">e</span><span class="p">.</span><span class="n">printStackTrace</span><span class="p">();</span>
        <span class="p">}</span> <span class="n">catch</span> <span class="p">(</span><span class="n">IOException</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// TODO Auto-generated catch block</span>
            <span class="n">e</span><span class="p">.</span><span class="n">printStackTrace</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h3>Apache Avro<sup id="sf-fen-bu-shi-ji-suan-xi-lie-iyarnji-chu-ku-chu-tan-2-back"><a href="#sf-fen-bu-shi-ji-suan-xi-lie-iyarnji-chu-ku-chu-tan-2" class="simple-footnote" title="http://avro.apache.org/docs/current/gettingstartedjava.html">2</a></sup></h3>
<p>Apache Avro 是Hadoop 下的一个子项目。它本身既是一个序列化框架,同时也实现了RPC 的功能。Avro官网描述Avro的特性和功能如下:</p>
<ul>
<li>丰富的数据结构类型;</li>
<li>快速可压缩的二进制数据形式;</li>
<li>存储持久数据的文件容器;</li>
<li>提供远程过程调用 RPC;</li>
<li>简单的动态语言结合功能。</li>
</ul>
<p>相比于Apache Thrift和Google Protocol Buffers,Apache Avro具有以下特点:</p>
<ul>
<li>支持动态模式 。Avro 不需要生成代码,这有利于搭建通用的数据处理系统,同时避免了代码入侵。</li>
<li>数据无须加标签 。读取数据前,Avro能够获取模式定义,这使得Avro在数据编码时只需要保留更少的类型信息,有利于减少序列化后的数据大小。</li>
<li>无须手工分配的域标识。Thrift 和 Protocol Buffers使用一个用户添加的整型域唯一性定义一个字段,而Avro则直接使用域名,该方法更加直观、更加易扩展。</li>
</ul>
<p>编写一个 Avro 应用也需如下三步:</p>
<ul>
<li>定义消息格式文件,通常以 avro 作为扩展名;</li>
<li>使用Avro编译器生成特定语言的代码文件(可选);</li>
<li>使用Avro库提供的 API 来编写应用程序。</li>
</ul>
<h4>定义消息格式文件</h4>
<p>Avro schema是用JSON定义的。它有基本数据类型(null, boolean, int, long, float, double, bytes, string)以及复合数据类型(record, enum, array, map, union, and fixed)组成。以下给出一个具体实例user.avsc:</p>
<div class="highlight"><pre><span class="p">{</span><span class="s2">"namespace"</span><span class="o">:</span> <span class="s2">"example.avro"</span><span class="o">,</span>
    <span class="s2">"type"</span><span class="o">:</span> <span class="s2">"record"</span><span class="o">,</span>
    <span class="s2">"name"</span><span class="o">:</span> <span class="s2">"User"</span><span class="o">,</span>
    <span class="s2">"fields"</span><span class="o">:</span> <span class="cp">[</span>
        <span class="p">{</span><span class="s2">"name"</span><span class="p">:</span> <span class="s2">"name"</span><span class="p">,</span> <span class="s2">"type"</span><span class="p">:</span> <span class="s2">"string"</span><span class="p">},</span>
        <span class="p">{</span><span class="s2">"name"</span><span class="p">:</span> <span class="s2">"favorite_number"</span><span class="p">,</span>  <span class="s2">"type"</span><span class="p">:</span> <span class="err">[</span><span class="s2">"int"</span><span class="p">,</span> <span class="s2">"null"</span><span class="cp">]</span><span class="p">}</span><span class="o">,</span>
        <span class="p">{</span><span class="s2">"name"</span><span class="o">:</span> <span class="s2">"favorite_color"</span><span class="o">,</span> <span class="s2">"type"</span><span class="o">:</span> <span class="cp">[</span><span class="s2">"string"</span><span class="p">,</span> <span class="s2">"null"</span><span class="cp">]</span><span class="p">}</span>
    <span class="o">]</span>
<span class="err">}</span>
</pre></div>


<h4>Compiling the schema(Optional)</h4>
<p>同Protocol Buffer一样,Apache Avro可以根据Scheme定义自动生成JAVA类。我们可以通过avro-tools工具生成相应的类: </p>
<div class="highlight"><pre><span class="nb">java</span> <span class="na">-jar</span> <span class="p">/</span><span class="nb">path</span><span class="p">/</span><span class="k">to</span><span class="p">/</span><span class="nx">avro</span><span class="na">-tools</span><span class="o">-</span><span class="mf">1.7.6</span><span class="bp">.</span><span class="nx">jar</span> <span class="nb">compile</span> <span class="nx">schema</span> <span class="o">&lt;</span><span class="nx">schema</span> <span class="nb">file</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="nx">destination</span><span class="o">&gt;</span>
</pre></div>


<p>就我们的例子而言,可以通过如下命令生成对应的JAVA类:</p>
<div class="highlight"><pre><span class="n">java</span> <span class="o">-</span><span class="n">jar</span> <span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">avro</span><span class="o">-</span><span class="n">tools</span><span class="o">-</span><span class="mf">1.7.6</span><span class="p">.</span><span class="n">jar</span> <span class="n">compile</span> <span class="n">schema</span> <span class="n">user</span><span class="p">.</span><span class="n">avsc</span>
</pre></div>


<p>生成的类结构如下图所示:</p>
<p><img alt="User Structure" src="http://i1302.photobucket.com/albums/ag136/qingyuanxingsi/blog/User_zps8e56f737.png"></p>
<h4>序列化与反序列化</h4>
<p>当我们直接使用生成的JAVA类时,可通过如下方法持久化一个User:</p>
<div class="highlight"><pre><span class="c1">// Serialize user user1 to disk</span>
<span class="n">File</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="p">(</span><span class="s">"user.avro"</span><span class="p">);</span>
<span class="n">DatumWriter</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">userDatumWriter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SpecificDatumWriter</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span><span class="p">(</span><span class="n">User</span><span class="p">.</span><span class="k">class</span><span class="p">);</span>
<span class="n">DataFileWriter</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">dataFileWriter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DataFileWriter</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span><span class="p">(</span><span class="n">userDatumWriter</span><span class="p">);</span>
<span class="n">dataFileWriter</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">user1</span><span class="p">.</span><span class="n">getSchema</span><span class="p">(),</span> <span class="k">new</span> <span class="n">File</span><span class="p">(</span><span class="s">"users.avro"</span><span class="p">));</span>
<span class="n">dataFileWriter</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">user1</span><span class="p">);</span>
<span class="n">dataFileWriter</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
</pre></div>


<p>我们首先创建一个<code>DatumWriter</code>, 它负责将JAVA对象转化成内存中的序列化格式;SpecificDatumWriter类则与具体的生成类相关并从指定类中抽取Schema定义信息。 然后我们创建一个<code>DataFileWriter</code>,它将内存中的持久化对象以及Schema定义持久化到文件中。 最后,我们通过其append方法添加一个User实例。</p>
<p>当我们要反序列化时,则可以使用如下方法:</p>
<div class="highlight"><pre><span class="c1">// Deserialize Users from disk</span>
<span class="n">DatumReader</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">userDatumReader</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SpecificDatumReader</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span><span class="p">(</span><span class="n">User</span><span class="p">.</span><span class="k">class</span><span class="p">);</span>
<span class="n">DataFileReader</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">dataFileReader</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DataFileReader</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">userDatumReader</span><span class="p">);</span>
<span class="n">User</span> <span class="n">user</span> <span class="o">=</span> <span class="k">null</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">dataFileReader</span><span class="p">.</span><span class="n">hasNext</span><span class="p">())</span> <span class="p">{</span>
<span class="c1">// Reuse user object by passing it to next(). This saves us from</span>
<span class="c1">// allocating and garbage collecting many objects for files with</span>
<span class="c1">// many items.</span>
<span class="n">user</span> <span class="o">=</span> <span class="n">dataFileReader</span><span class="p">.</span><span class="n">next</span><span class="p">(</span><span class="n">user</span><span class="p">);</span>
<span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">user</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>反序列化与序列化基本相同,我们首先创建一个SpecificDatumReader,它将内存中的对象反序列化为我们的User实例,我们将DatumReader以及之前创建的文件传给DataFileReader,它从文件中读取信息。接着我们使用DataFileReader遍历已经序列化的User然后将反序列化之后的信息打印到标准输出流。</p>
<p>当然,正如我们上述介绍Avro的特性时提到的那样,其实Avro可以不必生成对应的JAVA类,也就是说我们可以仅依靠Scheme定义直接序列化、反序列化对象。</p>
<p>我们可以通过如下方法创建User实例:</p>
<div class="highlight"><pre><span class="c1">//Read Scheme definition and create a Schema object</span>
<span class="n">Schema</span> <span class="n">schema</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Parser</span><span class="p">().</span><span class="n">parse</span><span class="p">(</span><span class="k">new</span> <span class="n">File</span><span class="p">(</span><span class="s">"user.avsc"</span><span class="p">));</span>

<span class="c1">//Create user using above Schema </span>
<span class="n">GenericRecord</span> <span class="n">user1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">GenericData</span><span class="p">.</span><span class="n">Record</span><span class="p">(</span><span class="n">schema</span><span class="p">);</span>
<span class="n">user1</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="s">"name"</span><span class="p">,</span> <span class="s">"Alyssa"</span><span class="p">);</span>
<span class="n">user1</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="s">"favorite_number"</span><span class="p">,</span> <span class="mh">256</span><span class="p">);</span>
<span class="c1">// Leave favorite color null</span>

<span class="n">GenericRecord</span> <span class="n">user2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">GenericData</span><span class="p">.</span><span class="n">Record</span><span class="p">(</span><span class="n">schema</span><span class="p">);</span>
<span class="n">user2</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="s">"name"</span><span class="p">,</span> <span class="s">"Ben"</span><span class="p">);</span>
<span class="n">user2</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="s">"favorite_number"</span><span class="p">,</span> <span class="mh">7</span><span class="p">);</span>
<span class="n">user2</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="s">"favorite_color"</span><span class="p">,</span> <span class="s">"red"</span><span class="p">);</span>
</pre></div>


<p>接着,我们可以以如下方式序列化User实例:</p>
<div class="highlight"><pre><span class="c1">// Serialize user1 and user2 to disk</span>
<span class="n">File</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="p">(</span><span class="s">"users.avro"</span><span class="p">);</span>
<span class="n">DatumWriter</span><span class="o">&lt;</span><span class="n">GenericRecord</span><span class="o">&gt;</span> <span class="n">datumWriter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">GenericDatumWriter</span><span class="o">&lt;</span><span class="n">GenericRecord</span><span class="o">&gt;</span><span class="p">(</span><span class="n">schema</span><span class="p">);</span>
<span class="n">DataFileWriter</span><span class="o">&lt;</span><span class="n">GenericRecord</span><span class="o">&gt;</span> <span class="n">dataFileWriter</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DataFileWriter</span><span class="o">&lt;</span><span class="n">GenericRecord</span><span class="o">&gt;</span><span class="p">(</span><span class="n">datumWriter</span><span class="p">);</span>
<span class="n">dataFileWriter</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
<span class="n">dataFileWriter</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">user1</span><span class="p">);</span>
<span class="n">dataFileWriter</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">user2</span><span class="p">);</span>
<span class="n">dataFileWriter</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
</pre></div>


<p>以上序列化过程基本和使用Code Generation时相同。</p>
<p>最后,我们反序列化如上对象,当然,和之前Code Generation时也类似:</p>
<div class="highlight"><pre><span class="c1">// Deserialize users from disk</span>
<span class="n">DatumReader</span><span class="o">&lt;</span><span class="n">GenericRecord</span><span class="o">&gt;</span> <span class="n">datumReader</span> <span class="o">=</span> <span class="k">new</span> <span class="n">GenericDatumReader</span><span class="o">&lt;</span><span class="n">GenericRecord</span><span class="o">&gt;</span><span class="p">(</span><span class="n">schema</span><span class="p">);</span>
<span class="n">DataFileReader</span><span class="o">&lt;</span><span class="n">GenericRecord</span><span class="o">&gt;</span> <span class="n">dataFileReader</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DataFileReader</span><span class="o">&lt;</span><span class="n">GenericRecord</span><span class="o">&gt;</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">datumReader</span><span class="p">);</span>
<span class="n">GenericRecord</span> <span class="n">user</span> <span class="o">=</span> <span class="k">null</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">dataFileReader</span><span class="p">.</span><span class="n">hasNext</span><span class="p">())</span> <span class="p">{</span>
<span class="c1">// Reuse user object by passing it to next(). This saves us from</span>
<span class="c1">// allocating and garbage collecting many objects for files with</span>
<span class="c1">// many items.</span>
<span class="n">user</span> <span class="o">=</span> <span class="n">dataFileReader</span><span class="p">.</span><span class="n">next</span><span class="p">(</span><span class="n">user</span><span class="p">);</span>
<span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">user</span><span class="p">);</span>
</pre></div>


<p>以下给出一完整实例:</p>
<div class="highlight"><pre><span class="nx">package</span> <span class="nx">org.qingyuanxingsi.avrodemo</span><span class="p">;</span>

<span class="k">import</span> <span class="nx">java.io.File</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">java.io.IOException</span><span class="p">;</span>

<span class="k">import</span> <span class="nx">org.apache.avro.Schema</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">org.apache.avro.Schema.Parser</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">org.apache.avro.file.DataFileReader</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">org.apache.avro.file.DataFileWriter</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">org.apache.avro.generic.GenericData</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">org.apache.avro.generic.GenericRecord</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">org.apache.avro.io.DatumReader</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">org.apache.avro.io.DatumWriter</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">org.apache.avro.specific.SpecificDatumReader</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">org.apache.avro.specific.SpecificDatumWriter</span><span class="p">;</span>

<span class="k">import</span> <span class="nx">example.avro.User</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * A toy example demonstrates the use of Apache Avro</span>
<span class="cm"> * </span>
<span class="cm"> * @author qingyuanxingsi</span>
<span class="cm"> * @version 1.0</span>
<span class="cm"> */</span>
<span class="k">public</span> <span class="nf">class</span> <span class="nx">AvroDemo</span> <span class="p">{</span>
    <span class="c1">// File Path storing demo data</span>
    <span class="k">private</span> <span class="nf">static</span> <span class="nx">final</span> <span class="kt">String</span> <span class="n">FILE_PATH</span> <span class="o">=</span> <span class="s2">"user.dat"</span><span class="p">;</span>

    <span class="cm">/**</span>
<span class="cm">     * Test Case</span>
<span class="cm">     * </span>
<span class="cm">     * @param args</span>
<span class="cm">     */</span>
    <span class="k">public</span> <span class="nf">static</span> <span class="bp">void</span> <span class="nx">main</span><span class="p">(</span><span class="kt">String</span><span class="err">[</span><span class="cp">]</span> args) {
        //Avro with code generation
        avroWithCode();
        //Avro without code generation
        avroWithoutCode();

    }

    /**
     * Avro without code generation
     */
    private static void avroWithoutCode() {
        // TODO Auto-generated method stub
        System.out.println("-----------------------------");
        System.out.println("2.Avro without code generation!");
        System.out.println("-----------------------------");
        Parser parser = new Parser();
        try {
            Schema schema = parser.parse(new File("user.avsc"));
            GenericRecord user = new GenericData.Record(schema);
            user.put("name", "qingyuanxingsi");
            user.put("favorite_number", 6);
            user.put("favorite_color", "BLUE");
            // Serialize it
            File file = new File(FILE_PATH);
            DatumWriter<span class="nt">&lt;GenericRecord&gt;</span> userDatumWriter = new SpecificDatumWriter<span class="nt">&lt;GenericRecord&gt;</span>(
                    schema);
            DataFileWriter<span class="nt">&lt;GenericRecord&gt;</span> dataFileWriter = new DataFileWriter<span class="nt">&lt;GenericRecord&gt;</span>(
                    userDatumWriter);
            try {
                dataFileWriter.create(schema, file);
                dataFileWriter.append(user);
                dataFileWriter.close();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }

            // Deserialize Users from disk
            DatumReader<span class="nt">&lt;GenericRecord&gt;</span> userDatumReader = new SpecificDatumReader<span class="nt">&lt;GenericRecord&gt;</span>(
                    schema);
            DataFileReader<span class="nt">&lt;GenericRecord&gt;</span> dataFileReader;
            try {
                dataFileReader = new DataFileReader<span class="nt">&lt;GenericRecord&gt;</span>(file, userDatumReader);
                GenericRecord tmp = null;
                while (dataFileReader.hasNext()) {
                    // Reuse user object by passing it to next(). This saves us from
                    // allocating and garbage collecting many objects for files with
                    // many items.
                    tmp = dataFileReader.next(tmp);
                    System.out.println(tmp);
                }
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    /**
     * Avro with code generation
     */
    private static void avroWithCode() {
        // TODO Auto-generated method stub
        System.out.println("-----------------------------");
        System.out.println("1.Avro with code generation!");
        System.out.println("-----------------------------");
        User user = User.newBuilder().setName("qingyuanxingsi")
                .setFavoriteNumber(5).setFavoriteColor("PURPLE").build();
        // Serialize it
        File file = new File(FILE_PATH);
        DatumWriter<span class="nt">&lt;User&gt;</span> userDatumWriter = new SpecificDatumWriter<span class="nt">&lt;User&gt;</span>(
                User.class);
        DataFileWriter<span class="nt">&lt;User&gt;</span> dataFileWriter = new DataFileWriter<span class="nt">&lt;User&gt;</span>(
                userDatumWriter);
        try {
            dataFileWriter.create(user.getSchema(), file);
            dataFileWriter.append(user);
            dataFileWriter.close();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

        // Deserialize Users from disk
        DatumReader<span class="nt">&lt;User&gt;</span> userDatumReader = new SpecificDatumReader<span class="nt">&lt;User&gt;</span>(
                User.class);
        DataFileReader<span class="nt">&lt;User&gt;</span> dataFileReader;
        try {
            dataFileReader = new DataFileReader<span class="nt">&lt;User&gt;</span>(file, userDatumReader);
            User tmp = null;
            while (dataFileReader.hasNext()) {
                // Reuse user object by passing it to next(). This saves us from
                // allocating and garbage collecting many objects for files with
                // many items.
                tmp = dataFileReader.next(tmp);
                System.out.println(tmp);
            }
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }
}
</pre></div>


<h2>也说动态代理<sup id="sf-fen-bu-shi-ji-suan-xi-lie-iyarnji-chu-ku-chu-tan-3-back"><a href="#sf-fen-bu-shi-ji-suan-xi-lie-iyarnji-chu-ku-chu-tan-3" class="simple-footnote" title="参考java动态代理(JDK和cglib)">3</a></sup></h2>
<p>Hadoop RPC中设计的基本设计模式就是代理模式,因此想要看懂RPC部分源码，代理不可不知。</p>
<p>代理模式是常用的java设计模式，他的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。 </p>
<p>按照代理的创建时期，代理类可以分为两种。 </p>
<ul>
<li>静态代理：由程序员创建或特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。 </li>
<li>动态代理：在程序运行时，运用反射机制动态创建而成。 </li>
</ul>
<p>静态代理的基本原理我们就不说了,简而言之就是代理类和委托类实现相同的借口,Client通过代理类调用实现类的方法(代理类持有委托类的实例)。然后这样做有一个很明显的弊端，那就是每一个代理类只能为一个接口服务，这样一来程序开发中必然会产生过多的代理，而且，所有的代理操作除了调用的方法不一样之外，其他的操作都一样，则此时肯定是重复代码。解决这一问题最好的做法是可以通过一个代理类完成全部的代理功能，那么此时就必须使用动态代理完成。动态代理类的字节码在程序运行时由Java反射机制动态生成，无需程序员手工编写它的源代码。动态代理类不仅简化了编程工作，而且提高了软件系统的可扩展性，因为Java反射机制可以生成任意类型的动态代理类。<code>java.lang.reflect</code>包中的Proxy类和InvocationHandler 接口提供了生成动态代理类的能力。 </p>
<div class="highlight"><pre><span class="n">InvocationHandler</span><span class="err">接口：</span>

<span class="n">public</span> <span class="n">interface</span> <span class="n">InvocationHandler</span> <span class="p">{</span> 
    <span class="n">public</span> <span class="n">Object</span> <span class="n">invoke</span><span class="p">(</span><span class="n">Object</span> <span class="n">proxy</span><span class="p">,</span><span class="n">Method</span> <span class="n">method</span><span class="p">,</span><span class="n">Object</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="n">throws</span> <span class="n">Throwable</span><span class="p">;</span> 
<span class="p">}</span> 
<span class="err">参数说明：</span> 
<span class="n">Object</span> <span class="n">proxy</span><span class="err">：指被代理的对象。</span> 
<span class="n">Method</span> <span class="n">method</span><span class="err">：要调用的方法</span> 
<span class="n">Object</span><span class="p">[]</span> <span class="n">args</span><span class="err">：方法调用时所需要的参数</span>
</pre></div>


<p>可以将InvocationHandler接口的子类想象成一个代理的最终操作类，替换掉ProxySubject。 </p>
<p>Proxy类是专门完成代理的操作类，可以通过此类为一个或多个接口动态地生成实现类，此类提供了如下的操作方法： </p>
<div class="highlight"><pre><span class="kr">public</span> <span class="kr">static</span> <span class="nb">Object</span> <span class="nx">newProxyInstance</span><span class="p">(</span><span class="nx">ClassLoader</span> <span class="nx">loader</span><span class="p">,</span> <span class="nx">Class</span><span class="cp">&lt;?</span><span class="o">&gt;</span><span class="p">[]</span> <span class="nx">interfaces</span><span class="p">,</span> 
<span class="nx">InvocationHandler</span> <span class="nx">h</span><span class="p">)</span> <span class="nx">throws</span> <span class="nx">IllegalArgumentException</span> 
<span class="err">参数说明：</span> 
<span class="nx">ClassLoader</span> <span class="nx">loader</span><span class="err">：类加载器</span> 
<span class="nx">Class</span><span class="o">&lt;?&gt;</span><span class="p">[]</span> <span class="nx">interfaces</span><span class="err">：得到全部的接口</span> 
<span class="nx">InvocationHandler</span> <span class="nx">h</span><span class="err">：得到</span><span class="nx">InvocationHandler</span><span class="err">接口的子类实例</span>
</pre></div>


<blockquote>
<p>NOTE:类加载器 
在Proxy类中的newProxyInstance（）方法中需要一个ClassLoader类的实例，ClassLoader实际上对应的是类加载器，在Java中主要有以下三种类加载器; </p>
<ul>
<li>Booststrap ClassLoader：此加载器采用C++编写，一般开发中是看不到的； </li>
<li>Extension ClassLoader：用来进行扩展类的加载，一般对应的是jre\lib\ext目录中的类; </li>
<li>AppClassLoader：(默认)加载classpath指定的类，是最常使用的是一种加载器。 </li>
</ul>
</blockquote>
<p>以下给出一具体实例:</p>
<div class="highlight"><pre><span class="c1">//BookFacade.java,define interfaces</span>
<span class="kn">package</span> <span class="n">org</span><span class="p">.</span><span class="n">qingyuanxingsi</span><span class="p">.</span><span class="n">proxypattern</span><span class="p">;</span>

<span class="n">public</span> <span class="k">interface</span> <span class="n">BookFacade</span> <span class="p">{</span>
    <span class="c1">//Add book interface</span>
    <span class="n">public</span> <span class="k">void</span> <span class="n">addBook</span><span class="p">();</span>  
<span class="p">}</span>

<span class="c1">//BookFacadeImpl.java,具体实现类</span>
<span class="kn">package</span> <span class="n">org</span><span class="p">.</span><span class="n">qingyuanxingsi</span><span class="p">.</span><span class="n">proxypattern</span><span class="p">;</span>

<span class="n">public</span> <span class="k">class</span> <span class="n">BookFacadeImpl</span> <span class="n">implements</span> <span class="n">BookFacade</span> <span class="p">{</span>

    <span class="p">@</span><span class="n">Override</span>
    <span class="n">public</span> <span class="k">void</span> <span class="n">addBook</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// TODO Auto-generated method stub</span>
        <span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"Adding books to the database!"</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="c1">//BookFacadeProxy.java,生成动态代理</span>
<span class="kn">package</span> <span class="n">org</span><span class="p">.</span><span class="n">qingyuanxingsi</span><span class="p">.</span><span class="n">proxypattern</span><span class="p">;</span>

<span class="kn">import</span> <span class="nn">java</span><span class="p">.</span><span class="n">lang</span><span class="p">.</span><span class="n">reflect</span><span class="p">.</span><span class="n">InvocationHandler</span><span class="p">;</span>
<span class="kn">import</span> <span class="nn">java</span><span class="p">.</span><span class="n">lang</span><span class="p">.</span><span class="n">reflect</span><span class="p">.</span><span class="n">Method</span><span class="p">;</span>
<span class="kn">import</span> <span class="nn">java</span><span class="p">.</span><span class="n">lang</span><span class="p">.</span><span class="n">reflect</span><span class="p">.</span><span class="n">Proxy</span><span class="p">;</span>

<span class="n">public</span> <span class="k">class</span> <span class="n">BookFacadeProxy</span> <span class="n">implements</span> <span class="n">InvocationHandler</span> <span class="p">{</span>
    <span class="n">private</span> <span class="n">Object</span> <span class="n">target</span><span class="p">;</span>

    <span class="n">public</span> <span class="n">Object</span> <span class="k">bind</span><span class="p">(</span><span class="n">Object</span> <span class="n">target</span><span class="p">){</span>
        <span class="k">this</span><span class="p">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span>
        <span class="c1">//Get the proxy object</span>
        <span class="c1">//Interfaces must be bound,this is one drawback(which can be fixed by cglib)</span>
        <span class="k">return</span> <span class="n">Proxy</span><span class="p">.</span><span class="n">newProxyInstance</span><span class="p">(</span><span class="n">target</span><span class="p">.</span><span class="n">getClass</span><span class="p">().</span><span class="n">getClassLoader</span><span class="p">(),</span> <span class="n">target</span><span class="p">.</span><span class="n">getClass</span><span class="p">().</span><span class="n">getInterfaces</span><span class="p">(),</span> <span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="p">@</span><span class="n">Override</span>
    <span class="n">public</span> <span class="n">Object</span> <span class="n">invoke</span><span class="p">(</span><span class="n">Object</span> <span class="n">proxy</span><span class="p">,</span> <span class="n">Method</span> <span class="n">method</span><span class="p">,</span> <span class="n">Object</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
            <span class="n">throws</span> <span class="n">Throwable</span> <span class="p">{</span>
        <span class="c1">// TODO Auto-generated method stub</span>
        <span class="n">Object</span> <span class="n">result</span> <span class="o">=</span> <span class="k">null</span><span class="p">;</span>
        <span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"Transaction begins!"</span><span class="p">);</span>
        <span class="c1">//Execute the method</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">method</span><span class="p">.</span><span class="n">invoke</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
        <span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"Transaction ends!"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//TestProxy.java,test case</span>
<span class="kn">package</span> <span class="n">org</span><span class="p">.</span><span class="n">qingyuanxingsi</span><span class="p">.</span><span class="n">proxypattern</span><span class="p">;</span>

<span class="n">public</span> <span class="k">class</span> <span class="n">TestProxy</span> <span class="p">{</span>

    <span class="n">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">main</span><span class="p">(</span><span class="n">String</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// TODO Auto-generated method stub</span>
        <span class="n">BookFacadeProxy</span> <span class="n">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BookFacadeProxy</span><span class="p">();</span>
        <span class="n">BookFacade</span> <span class="n">bookProxy</span> <span class="o">=</span> <span class="p">(</span><span class="n">BookFacade</span><span class="p">)</span><span class="n">proxy</span><span class="p">.</span><span class="k">bind</span><span class="p">(</span><span class="k">new</span> <span class="n">BookFacadeImpl</span><span class="p">());</span>
        <span class="n">bookProxy</span><span class="p">.</span><span class="n">addBook</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>但是，JDK的动态代理依靠接口实现，如果有些类并没有实现接口，则不能使用JDK代理，这就要使用cglib动态代理了。JDK的动态代理机制只能代理实现了接口的类，而不能实现接口的类就不能实现JDK的动态代理，cglib是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。具体示例如下:</p>
<div class="highlight"><pre><span class="c1">//BookFacadeImpl1.java,没有实现接口的实现类</span>
<span class="kn">package</span> <span class="n">net</span><span class="p">.</span><span class="n">battier</span><span class="p">.</span><span class="n">dao</span><span class="p">.</span><span class="n">impl</span><span class="p">;</span>

<span class="cm">/** </span>
<span class="cm"> * 这个是没有实现接口的实现类 </span>
<span class="cm"> *  </span>
<span class="cm"> * @author student </span>
<span class="cm"> *  </span>
<span class="cm"> */</span>  
<span class="n">public</span> <span class="k">class</span> <span class="n">BookFacadeImpl1</span> <span class="p">{</span>  
    <span class="n">public</span> <span class="k">void</span> <span class="n">addBook</span><span class="p">()</span> <span class="p">{</span>  
        <span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"增加图书的普通方法..."</span><span class="p">);</span>  
    <span class="p">}</span>  
<span class="p">}</span>

<span class="c1">//BookfacadeCglib.java,使用cglib实现动态代理</span>
<span class="kn">package</span> <span class="n">net</span><span class="p">.</span><span class="n">battier</span><span class="p">.</span><span class="n">proxy</span><span class="p">;</span>

<span class="kn">import</span> <span class="nn">java</span><span class="p">.</span><span class="n">lang</span><span class="p">.</span><span class="n">reflect</span><span class="p">.</span><span class="n">Method</span><span class="p">;</span>

<span class="kn">import</span> <span class="nn">net</span><span class="p">.</span><span class="n">sf</span><span class="p">.</span><span class="n">cglib</span><span class="p">.</span><span class="n">proxy</span><span class="p">.</span><span class="n">Enhancer</span><span class="p">;</span>  
<span class="kn">import</span> <span class="nn">net</span><span class="p">.</span><span class="n">sf</span><span class="p">.</span><span class="n">cglib</span><span class="p">.</span><span class="n">proxy</span><span class="p">.</span><span class="n">MethodInterceptor</span><span class="p">;</span>  
<span class="kn">import</span> <span class="nn">net</span><span class="p">.</span><span class="n">sf</span><span class="p">.</span><span class="n">cglib</span><span class="p">.</span><span class="n">proxy</span><span class="p">.</span><span class="n">MethodProxy</span><span class="p">;</span>

<span class="cm">/** </span>
<span class="cm"> * 使用cglib动态代理 </span>
<span class="cm"> *  </span>
<span class="cm"> * @author student </span>
<span class="cm"> *  </span>
<span class="cm"> */</span>  
<span class="n">public</span> <span class="k">class</span> <span class="n">BookFacadeCglib</span> <span class="n">implements</span> <span class="n">MethodInterceptor</span> <span class="p">{</span>  
    <span class="n">private</span> <span class="n">Object</span> <span class="n">target</span><span class="p">;</span>

    <span class="cm">/** </span>
<span class="cm">     * 创建代理对象 </span>
<span class="cm">     *  </span>
<span class="cm">     * @param target </span>
<span class="cm">     * @return </span>
<span class="cm">     */</span>  
    <span class="n">public</span> <span class="n">Object</span> <span class="n">getInstance</span><span class="p">(</span><span class="n">Object</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>  
        <span class="k">this</span><span class="p">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span>  
        <span class="n">Enhancer</span> <span class="n">enhancer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Enhancer</span><span class="p">();</span>  
        <span class="n">enhancer</span><span class="p">.</span><span class="n">setSuperclass</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">target</span><span class="p">.</span><span class="n">getClass</span><span class="p">());</span>  
        <span class="c1">// 回调方法  </span>
        <span class="n">enhancer</span><span class="p">.</span><span class="n">setCallback</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>  
        <span class="c1">// 创建代理对象  </span>
        <span class="k">return</span> <span class="n">enhancer</span><span class="p">.</span><span class="n">create</span><span class="p">();</span>  
    <span class="p">}</span>

    <span class="p">@</span><span class="n">Override</span>  
    <span class="c1">// 回调方法  </span>
    <span class="n">public</span> <span class="n">Object</span> <span class="n">intercept</span><span class="p">(</span><span class="n">Object</span> <span class="n">obj</span><span class="p">,</span> <span class="n">Method</span> <span class="n">method</span><span class="p">,</span> <span class="n">Object</span><span class="p">[]</span> <span class="n">args</span><span class="p">,</span>  
            <span class="n">MethodProxy</span> <span class="n">proxy</span><span class="p">)</span> <span class="n">throws</span> <span class="n">Throwable</span> <span class="p">{</span>  
        <span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"事物开始"</span><span class="p">);</span>  
        <span class="n">proxy</span><span class="p">.</span><span class="n">invokeSuper</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>  
        <span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s">"事物结束"</span><span class="p">);</span>  
        <span class="k">return</span> <span class="k">null</span><span class="p">;</span>


    <span class="p">}</span>

<span class="p">}</span>

<span class="c1">//TestCglib.java,a test case</span>
<span class="kn">package</span> <span class="n">net</span><span class="p">.</span><span class="n">battier</span><span class="p">.</span><span class="n">test</span><span class="p">;</span>

<span class="kn">import</span> <span class="nn">net</span><span class="p">.</span><span class="n">battier</span><span class="p">.</span><span class="n">dao</span><span class="p">.</span><span class="n">impl</span><span class="p">.</span><span class="n">BookFacadeImpl1</span><span class="p">;</span>  
<span class="kn">import</span> <span class="nn">net</span><span class="p">.</span><span class="n">battier</span><span class="p">.</span><span class="n">proxy</span><span class="p">.</span><span class="n">BookFacadeCglib</span><span class="p">;</span>

<span class="n">public</span> <span class="k">class</span> <span class="n">TestCglib</span> <span class="p">{</span>

    <span class="n">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">main</span><span class="p">(</span><span class="n">String</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>  
        <span class="n">BookFacadeCglib</span> <span class="n">cglib</span><span class="o">=</span><span class="k">new</span> <span class="n">BookFacadeCglib</span><span class="p">();</span>  
        <span class="n">BookFacadeImpl1</span> <span class="n">bookCglib</span><span class="o">=</span><span class="p">(</span><span class="n">BookFacadeImpl1</span><span class="p">)</span><span class="n">cglib</span><span class="p">.</span><span class="n">getInstance</span><span class="p">(</span><span class="k">new</span> <span class="n">BookFacadeImpl1</span><span class="p">());</span>  
        <span class="n">bookCglib</span><span class="p">.</span><span class="n">addBook</span><span class="p">();</span>  
    <span class="p">}</span>  
<span class="p">}</span>
</pre></div>


<h2>Dive Into Hadoop RPC</h2>
<p>好吧,具备了以上两个基础知识后,我们可以一睹Hadoop RPC的真面目了。</p>
<h3>RPC通信模型</h3>
<p>RPC 是一种通过网络从远程计算机上请求服务,但不需要了解底层网络技术的协议。RPC协议假定某些传输协议(如TCP或UDP等)已经存在,并通过这些传输协议为通信程序之间传递访问请求或者应答信息。在OSI网络通信模型中,RPC跨越了传输层和应用层。RPC使得开发分布式应用程序更加容易。RPC通常采用客户机 / 服务器模型。请求程序是一个客户机,而服务提供程序则是一个服务器。一个典型的RPC框架如下图所示,主要包括以下几个部分:</p>
<p><img alt="RPC ARCHITECTURE" src="http://i1302.photobucket.com/albums/ag136/qingyuanxingsi/blog/rpc_structure_zpsf7959ccf.png"></p>
<ul>
<li>通信模块。两个相互协作的通信模块实现请求-应答协议,它们在客户和服务器之间传递请求和应答消息,一般不会对数据包进行任何处理。请求–应答协议的实现方式有同步方式和异步方式两种。如下图所示,同步模式下客户端程序一直阻塞到服务器端发送的应答请求到达本地;
而异步模式不同,客户端将请求发送到服务器端后,不必等待应答返回,可以做其他事情,待服务器端处理完请求后,主动通知客户端。在高并发应用场景中,一般采用异步模式以降低访问延迟和提高带宽利用率。</li>
</ul>
<p><img alt="通信模式" src="http://i1302.photobucket.com/albums/ag136/qingyuanxingsi/blog/rpc_talk_zps10f24c93.png"></p>
<ul>
<li>Stub 程序。客户端和服务器端均包含Stub程序,可将之看做代理程序。它使得远程函数调用表现得跟本地调用一样,对用户程序完全透明。在客户端,它表现得就像一个本地程序,但不直接执行本地调用,而是将请求信息通过网络模块发送给服务器端。此外,当服务器发送应答后,它会解码对应结果。在服务器端,Stub程序依次进行解码请求消息中的参数、调用相应的服务过程和编码应答结果的返回值等处理。</li>
<li>调度程序。调度程序接收来自通信模块的请求消息,并根据其中的标识选择一个Stub程序进行处理。通常客户端并发请求量比较大时,会采用线程池提高处理效率。</li>
<li>客户程序/服务过程。请求的发出者和请求的处理者。如果是单机环境,客户程序可直接通过函数调用访问服务过程,但在分布式环境下,需要考虑网络通信,这不得增加通信模块和Stub程序(保证函数调用的透明性)。</li>
</ul>
<p>通常而言,一个 RPC 请求从发送到获取处理结果,所经历的步骤如下所示。</p>
<ol>
<li>客户程序以本地方式调用系统产生的Stub程序;</li>
<li>该Stub程序将函数调用信息按照网络通信模块的要求封装成消息包,并交给通信模块发送到远程服务器端。</li>
<li>远程服务器端接收此消息后,将此消息发送给相应的Stub程序;</li>
<li>Stub程序拆封消息,形成被调过程要求的形式,并调用对应函数;</li>
<li>被调用函数按照所获参数执行,并将结果返回给Stub程序;</li>
<li>Stub程序将此结果封装成消息,通过网络通信模块逐级地传送给客户程序。</li>
</ol>
<h3>RPC总体架构</h3>
<p>同其他RPC框架一样,Hadoop RPC主要分为四个部分,分别是序列化层、函数调用层、网络传输层和服务器端处理框架,具体实现机制如下:</p>
<ul>
<li>序列化层。序列化主要作用是将结构化对象转为字节流以便于通过网络进行传输或写入持久存储,在RPC框架中,它主要用于将用户请求中的参数或者应答转化成字节流以便跨机器传输。前面介绍的Protocol Buffers和Apache Avro均可用在序列化层,Hadoop本身也提供了一套序列化框架,一个类只要实现Writable接口即可支持对象序列化与反序列化。</li>
<li>函数调用层。函数调用层主要功能是定位要调用的函数并执行该函数,Hadoop RPC采用了Java反射机制与动态代理实现了函数调用。</li>
<li>网络传输层。网络传输层描述了Client与Server之间消息传输的方式,Hadoop RPC采用了基于TCP/IP的Socket机制。</li>
<li>服务器端处理框架。服务器端处理框架可被抽象为网络I/O模型,它描述了客户端与服务器端间信息交互方式,它的设计直接决定着服务器端的并发处理能力,常见的网络 I/O 模型有阻塞式 I/O、非阻塞式 I/O、事件驱动 I/O 等,而Hadoop RPC采用了基于<strong>Reactor设计模式</strong>的事件驱动 I/O 模型。</li>
</ul>
<p>Hadoop RPC 总体架构如下图所示,自下而上可分为两层,第一层是一个基于Java NIO (New I/O)实现的客户机–服务器(C/S)通信模型。其中,客户端将用户的调用方法及其参数封装成请求包后发送到服务器端。服务器端收到请求包后,经解包、调用函数、打包结果等一系列操作后,将结果返回给客户端。为了增强Sever端的扩展性和并发处理能力,Hadoop RPC采用了基于事件驱动的Reactor设计模式,在具体实现时,用到了JDK提供的各种功能包,主要包括java.nio(NIO)、java.lang.reflect(反射机制和动态代理)、java.net(网络编程库)等。第二层是供更上层程序直接调用的 RPC 接口,这些接口底层即为C/S通信模型。</p>
<p><img alt="Hadoop RPC总体架构" src="http://i1302.photobucket.com/albums/ag136/qingyuanxingsi/blog/whole_rpc_zpsddc95cd6.png"></p>
<h1>事件库</h1>
<hr>
<h1>状态机</h1>
<hr><script type="text/javascript">
    if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
        var mathjaxscript = document.createElement('script');
        mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
        mathjaxscript.type = 'text/javascript';
        mathjaxscript.src = 'https:' == document.location.protocol
                ? 'https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'
                : 'http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
        mathjaxscript[(window.opera ? "innerHTML" : "text")] =
            "MathJax.Hub.Config({" +
            "    config: ['MMLorHTML.js']," +
            "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
            "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
            "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
            "    displayAlign: 'center'," +
            "    displayIndent: '0em'," +
            "    showMathMenu: true," +
            "    tex2jax: { " +
            "        inlineMath: [ ['$','$'] ], " +
            "        displayMath: [ ['$$','$$'] ]," +
            "        processEscapes: true," +
            "        preview: 'TeX'," +
            "    }, " +
            "    'HTML-CSS': { " +
            "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'black ! important'} }" +
            "    } " +
            "}); ";
        (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
    }
</script>
<ol class="simple-footnotes"><li id="sf-fen-bu-shi-ji-suan-xi-lie-iyarnji-chu-ku-chu-tan-1">https://developers.google.com/protocol-buffers/docs/javatutorial <a href="#sf-fen-bu-shi-ji-suan-xi-lie-iyarnji-chu-ku-chu-tan-1-back" class="simple-footnote-back">↩</a></li><li id="sf-fen-bu-shi-ji-suan-xi-lie-iyarnji-chu-ku-chu-tan-2">http://avro.apache.org/docs/current/gettingstartedjava.html <a href="#sf-fen-bu-shi-ji-suan-xi-lie-iyarnji-chu-ku-chu-tan-2-back" class="simple-footnote-back">↩</a></li><li id="sf-fen-bu-shi-ji-suan-xi-lie-iyarnji-chu-ku-chu-tan-3">参考<a href="http://www.cnblogs.com/jqyp/archive/2010/08/20/1805041.html">java动态代理(JDK和cglib)</a> <a href="#sf-fen-bu-shi-ji-suan-xi-lie-iyarnji-chu-ku-chu-tan-3-back" class="simple-footnote-back">↩</a></li></ol> 
	<a class="btn btn-mini xsmall" href="./fen-bu-shi-ji-suan-xi-lie-iyarnji-chu-ku-chu-tan.html">
          <i class="icon-comment"></i> Comment </a>
	<hr />
      </div>
      
    </div>
    

 
        



    <div class='row-fluid'>
      <div class='article-title span9'> 
        <a href="./ji-qi-xue-xi-xi-lie-iiigaussian-models.html"><h1>机器学习系列(III):Gaussian Models</h1></a>
      </div>
    </div>
    <div class="row-fluid">
      <div class="span2">
<p>六 15 三月 2014 </p>

<p style="text-align: left;">
Filed under <a href="./category/machine-learning.html">Machine Learning</a>
</p>
<p style="text-align: left;">
 
    Tags <a href="./tag/machine-learning.html">Machine Learning</a> <a href="./tag/gaussian-models.html">Gaussian Models</a> <a href="./tag/generative-models.html">Generative Models</a> </p>
<p>
</p>
      </div>
      <div class="summary span8">
	<p>本文继上篇介绍离散数据的生成模型之后,介绍针对连续数据的生成模型。本篇博文主要介绍五点:首先我们会介绍一下Gaussian Distribution的基础知识以及对于Gaussian分布的MLE估计,第二部分我们则会着重介绍Gaussian Doscriminant Analysis,紧接该部分之后，第三部分我们会介绍基于Gaussian联合分布的Inference;第四部分我们介绍Linear Gaussian Systems,最后一部分我们给出针对高斯分布参数的估计方法。</p> 
	<a class="btn btn-mini xsmall" href="./ji-qi-xue-xi-xi-lie-iiigaussian-models.html">
          <i class="icon-plus-sign"></i> Read More </a>
	<hr />
      </div>
      
    </div>
      

 
        



    <div class='row-fluid'>
      <div class='article-title span9'> 
        <a href="./fen-bu-shi-ji-suan-yu-cun-chu-xi-lie-xu-zhang-chu-ru-men-jing.html"><h1>分布式计算与存储系列(序章):初入门径</h1></a>
      </div>
    </div>
    <div class="row-fluid">
      <div class="span2">
<p>二 11 三月 2014 </p>

<p style="text-align: left;">
Filed under <a href="./category/distributed-system.html">Distributed System</a>
</p>
<p style="text-align: left;">
 
    Tags <a href="./tag/fen-bu-shi-xi-tong.html">分布式系统</a> <a href="./tag/paxos.html">Paxos</a> <a href="./tag/zhi-xing-ha-xi-suan-fa.html">一致性哈希算法</a> </p>
<p>
</p>
      </div>
      <div class="summary span8">
	<p>本文主要就分布式存储的相关基础知识进行了梳理，分部分分别介绍了分布式系统的基本问题,单机存储系统、分布式系统的相关性能指标、分布式协议等,本文仅作为分布式计算与存储的入门材料，之后我们将从论文和源码两方面对分布式计算与存储的相关理论与实践进行更为深入的探讨。</p> 
	<a class="btn btn-mini xsmall" href="./fen-bu-shi-ji-suan-yu-cun-chu-xi-lie-xu-zhang-chu-ru-men-jing.html">
          <i class="icon-plus-sign"></i> Read More </a>
	<hr />
      </div>
      
    </div>
      

 
        



    <div class='row-fluid'>
      <div class='article-title span9'> 
        <a href="./ji-qi-xue-xi-xi-lie-iigenerative-models-for-discrete-data.html"><h1>机器学习系列(II):Generative models for discrete data</h1></a>
      </div>
    </div>
    <div class="row-fluid">
      <div class="span2">
<p>二 04 三月 2014 </p>

<p style="text-align: left;">
Filed under <a href="./category/machine-learning.html">Machine Learning</a>
</p>
<p style="text-align: left;">
 
    Tags <a href="./tag/machine-learning.html">Machine Learning</a> <a href="./tag/classfication.html">Classfication</a> <a href="./tag/generative-models.html">Generative Models</a> <a href="./tag/mutual-information.html">Mutual Information</a> </p>
<p>
</p>
      </div>
      <div class="summary span8">
	<p>本文为机器学习系列第二篇，主要研究一下离散数据生成模型。我们会介绍两种模型，一为Dirichlet-multinomial model,一为朴素贝叶斯分类器（Naive Bayes Classfier，NBC),最后我们介绍一下关于互信息的基本知识以及将其用于特征选择。</p> 
	<a class="btn btn-mini xsmall" href="./ji-qi-xue-xi-xi-lie-iigenerative-models-for-discrete-data.html">
          <i class="icon-plus-sign"></i> Read More </a>
	<hr />
      </div>
      
    </div>
      

 
        



    <div class='row-fluid'>
      <div class='article-title span9'> 
        <a href="./Decision Tree.html"><h1>机器学习系列(I):决策树算法</h1></a>
      </div>
    </div>
    <div class="row-fluid">
      <div class="span2">
<p>一 03 三月 2014 </p>

<p style="text-align: left;">
Filed under <a href="./category/machine-learning.html">Machine Learning</a>
</p>
<p style="text-align: left;">
 
    Tags <a href="./tag/machine-learning.html">Machine Learning</a> </p>
<p>
</p>
      </div>
      <div class="summary span8">
	<p>本文作为本博客的第一篇博文，简单说明了创建这个博客的目的；同时作为机器学习系列的第一篇，对决策树中的ID3和C4.5算法进行了梳理，对于ID3算法，我们给出了Python源码实现。</p> 
	<a class="btn btn-mini xsmall" href="./Decision Tree.html">
          <i class="icon-plus-sign"></i> Read More </a>
	<hr />
      </div>
      
    </div>
      
<div class="pagination">
<ul>
    <li class="prev disabled"><a href="#">&larr; Previous</a></li>

    <li class="active"><a href="./index.html">1</a></li>
    <li class=""><a href="./index2.html">2</a></li>

    <li class="next"><a href="./index2.html">Next &rarr;</a></li>

</ul>
</div>
 
  
        </div>
        
        
    </div>     </div> </div>

<!--footer-->
<div class="container">
  <div class="well" style="background-color: #E9EFF6">
    <div id="blog-footer">
      <div class="row-fluid">
	<div class="social span2" align="center" id="socialist">
	  <ul class="nav nav-list">
	    <li class="nav-header">
	      Social
	    </li>
	    <li><a href="https://github.com/qingyuanxingsi"><i class="icon-Github" style="color: #1f334b"></i>Github</a></li>

	  </ul>
	</div>
        <div class="links span2" align="center">
          <ul class="nav nav-list">
            <li class="nav-header"> 
              Links
            </li>
            
            <li><a href="http://freemind.pluskid.org">Pluskid</a></li>
            <li><a href="https://github.com/julycoding/The-Art-Of-Programming-By-July">结构之法 算法之道</a></li>
            <li><a href="http://www.nosqlnotes.net/">NOSQL Notes</a></li>
          </ul>
        </div>
	<div class="site-nav span2" align="center">
          <ul class="nav nav-list" id="site-links">
            <li class="nav-header"> 
              Site
            </li>
            <li><a href="."><i class="icon-home" style="color: #1f334b">
                </i>Home</a></li>
            <li><a href="./archives.html"><i class="icon-list" style="color: #1f334b">
                </i>Archives</a></li>
	    <li><a href="./tags.html"><i class="icon-tags" style="color: #1f334b">
                </i>Tags</a></li>
	    
            <li><a href="./" rel="alternate">
                <i class="icon-rss-sign" style="color: #1f334b"></i>
                Atom Feed</a></li>
	  </ul>

        </div>

      </div> <!--end of fluid row-->
    </div> <!--end of blog-footer-->
    <hr />
    <p align="center"><a href=".">Doodle World</a>
      &copy; qingyuanxingsi
    Powered by <a href="github.com/getpelican/pelican">Pelican</a> and
        <a href="https://twitter.github.com/bootstrap">Twitter Bootstrap</a>. 
        Icons by <a href="http://fortawesome.github.com/Font-Awesome">Font Awesome</a> and 
        <a href="http://gregoryloucas.github.com/Font-Awesome-More">Font Awesome More</a></p>

  </div> <!--end of well -->
</div> <!--end of container -->

<!--/footer-->
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
<script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.2.2/js/bootstrap.min.js"></script>


<script>var _gaq=[['_setAccount','UA-48582273-1'],['_trackPageview']];(function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.src='//www.google-analytics.com/ga.js';s.parentNode.insertBefore(g,s)}(document,'script'))</script>

</body>
</html>